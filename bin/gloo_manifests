#!/usr/local/bin/python3
# Generate gloo manifests files from Ambassador Mappings

import json
import os
import re
import subprocess
import sys

import yaml

# Create Helm template that may be used to instantiate a Gloo API Gateway to serve 
# one or more instances of the Tidepool services within a single Kubernetes cluster.

# These values must be provided by Helm when the resulting Helm template file is interpreted

VIRTUAL_HOST_KEY = '{{ $key }}'

"""The host served by the API Gateway"""
HOST = '{{ $spec.name }}'

"""The name used for SNI"""
EXTERNAL_HOST_NAME = '{{ $spec.name }}'

"""The name of the TLS secret containing the TLS cert"""
TLS_SECRET_NAME = '{{ $spec.tlssecret.name }}'

"""The namespace of the TLS secret containing the TLS cert"""
TLS_SECRET_NAMESPACE = '{{ $spec.tlssecret.namespace | default "default" }}'

"""The name of the Gateway Proxy Service"""
GATEWAY_PROXY_NAME = '{{ $.Value.globals.proxy.name }}'

"""The namespace of the Gateway Proxy Service"""
GATEWAY_PROXY_NAMESPACE = '{{ $.Values.global.proxy.namespace }}'

"""The environment being instantiated"""
ENVIRONMENT = '{{ $.Release.Namespace }}'

"""The name used to access the virtual service from other services"""
INTERNAL_VS_NAME = 'internal'

"""The name used to access the virtual service from the LoadBalancer."""
EXTERNAL_VS_NAME = ENVIRONMENT + "-external"


# These are the Kubernetes API versions for solo.io resources
GATEWAY_API_VERSION = 'gateway.solo.io/v1'
GLOO_API_VERSION = 'gloo.solo.io/v1'

CORS_POLICY_STRING = """
{
    "allowCredentials": true,
    "allowHeaders": [
        "authorization",
        "content-type",
        "x-tidepool-session-token",
        "x-tidepool-trace-request",
        "x-tidepool-trace-session"
    ],
    "allowMethods": [
        "GET",
        "POST",
        "PUT",
        "PATCH",
        "DELETE",
        "OPTIONS"
    ],
    "allowOriginRegex": [
        ".*"
    ],
    "exposeHeaders": [
        "x-tidepool-session-token",
        "x-tidepool-trace-request",
        "x-tidepool-trace-session"
    ],
    "maxAge": "600s"
}
"""
CORS_POLICY=json.loads(CORS_POLICY_STRING)

def metadata_spec(name, namespace):
    return { 
        "name": name,
        "namespace":  namespace
    }

class VirtualServiceBuilder:
    """Builds a Gloo virtual service manifest"""

    def __init__(self, routes, name, cors, protocol, hosts_served):
        useSSL = protocol == "https"
        if len(routes) > 0:
            self.virtual_service = {
                "apiVersion": GATEWAY_API_VERSION,
                "kind": "VirtualService",
                "metadata": metadata_spec(name, ENVIRONMENT),
                "spec": VirtualServiceBuilder.spec(name, routes, cors, useSSL, hosts_served)
            }
        else:
            self.virtual_service = None

    def get(self):
        return self.virtual_service

    @staticmethod
    def spec(name, routes, cors, useSSL, hosts_served):
        s = dict()
        if useSSL:
            s ["sslConfig"] = VirtualServiceBuilder.ssl_config(EXTERNAL_HOST_NAME)
        s["virtualHost"] = VirtualServiceBuilder.virtual_host(routes, hosts_served, cors)
        s["displayName"] = name
        return s 

    @staticmethod
    def virtual_host(routes, hosts_served, cors):
        """Return a virtual host"""
        v = dict()
        v["domains"] = hosts_served
        v["routes"] = routes
        if cors is not None:
            v["corsPolicy"] = cors
        return v
    
    @staticmethod
    def ssl_config(hostname):
        """Return the ssl config for the hostname"""
        return {
            "sniDomains": [ hostname ],
            "secretRef": metadata_spec(TLS_SECRET_NAME, TLS_SECRET_NAMESPACE)
        }
    
class UpstreamBuilder:
    """Builds a Gloo Upstream manifest"""
    def __init__(self, ref):
        self.upstream = {
            "apiVersion": GLOO_API_VERSION,
            "kind": "Upstream",
            "metadata": RoutesBuilder.ref( ref["service"], ref["port"]),
            "spec": UpstreamBuilder.spec(ref)
        }

    def get(self):
        return self.upstream

    @staticmethod
    def kube_spec(ref):
        return {
            "serviceName": ref["service"],
            "serviceNamespace": ENVIRONMENT,
            "servicePort": ref["port"]
        }

    @staticmethod
    def spec(ref):
        return {
            "upstreamSpec": {
                "kube" : UpstreamBuilder.kube_spec(ref)
            }
        }

class ExternalNameServiceBuilder:
    """Build an ExternalName Service manifest for a given component."""
    def __init__(self):
        self.service = {
            "apiVersion": "v1",
            "kind": "Service",
            "metadata":  metadata_spec(INTERNAL_VS_NAME, ENVIRONMENT),
            "spec": ExternalNameServiceBuilder.spec()
        }

    def get(self):
        return self.service        

    @staticmethod
    def spec():
        return {
            "type": "ExternalName",
            "externalName": GATEWAY_PROXY_NAME + "." + GATEWAY_PROXY_NAMESPACE + ".svc.cluster.local",
            "ports": ExternalNameServiceBuilder.ports()
        }
    
    @staticmethod
    def ports():
        return [ ExternalNameServiceBuilder.port() ]

    @staticmethod
    def port():
        return { "port": 80 }

class GatewayBuilder:
    """Builds a Gloo Gateway manifest."""

    def __init__(self, useSSL):
        g = dict()
        g["apiVersion"] = GATEWAY_API_VERSION
        g["kind"] = "Gateway"
        g["metadata"] = GatewayBuilder.metadata(useSSL)
        g["bindAddress"] = '::'
        if useSSL:
            g["bindPort"] = 8443
            g["useProxyProto"] = False # XXX check this
        else:
            g["bindPort"] = 8080
            g["useProxyProto"] = False # XXX check this
        g["ssl"] = useSSL
        self.gateway = g

    def get(self):
        return self.gateway

    @staticmethod
    def metadata(useSSL):
        return metadata_spec("gateway-ssl" if useSSL else "gateway", GATEWAY_PROXY_NAMESPACE)
    
class GatewayProxyServiceBuilder:
    """Builds a Gloo Gateway Proxy Service manifest."""

    def __init__(self, service_type, useSSL):
        self.service = {
            "apiVersion": "v1",
            "kind": "Service",
            "metadata": GatewayProxyServiceBuilder.metadata(useSSL),
            "spec": GatewayProxyServiceBuilder.spec(service_type, useSSL)
        }

    def get(self):
        return self.service

    @staticmethod
    def labels():
        return { "app" : "gloo", "gloo": GATEWAY_PROXY_NAME }
    
    @staticmethod
    def metadata(useSSL):
        suffix = "-ssl" if useSSL else ""
        m = metadata_spec(GATEWAY_PROXY_NAME + suffix, GATEWAY_PROXY_NAMESPACE)
        m["labels"] = GatewayProxyServiceBuilder.labels()
        return m

    @staticmethod
    def spec(service_type, useSSL):
        s = dict()
        s["ports"] = GatewayProxyServiceBuilder.ports(useSSL)
        s["selector"] = GatewayProxyServiceBuilder.selector()
        if service_type == "elb":
            s["externalTrafficPolicy"] = "Local"
            s["type"] = "LoadBalancer"
        elif service_type == "nlb":
            s["externalTrafficPolicy"] = "Local"
            s["type"] = "LoadBalancer"
            annotations = dict()
            annotations["service.beta.kubernetes.io/aws-load-balancer-type"] = "nlb"
            s["annotations"] = annotations
        elif service_type == "cluster":
            s["type"] = "ClusterIP"
        else:
            return None
        return spec

    @staticmethod
    def ports(useSSL):
        return [ https_port() if useSSL else http_port() ]
    
    @staticmethod
    def https_port():
        return {
            "name": "https",
            "port": 443,
            "protocol": "TCP",
            "targetPort": 8443
        }

    @staticmethod
    def http_port():
        return {
            "name": "http",
            "port": 80,
            "protocol": "TCP",
            "targetPort": 8080
        }
    
    @staticmethod
    def selector():
        return { "gloo" : GATEWAY_PROXY_NAME }
    
class RoutesBuilder:
    """Return a dict from host to routes for that host."""

    def __init__(self, mappings):
        self.routes_dict = dict()
        for mapping in mappings:
            self.add(mapping)

        for base,routes in self.routes_dict.items():
            self.routes_dict[base] = RoutesBuilder.ordered(routes)

    def get(self):
        return self.routes_dict

    def add(self, doc):
        """Appends a gloo route to a dictionary of routes whose keys are the virtual hosts."""
        host = doc["host"]
        if host not in self.routes_dict:
            self.routes_dict[host] = list()
        self.routes_dict[host].append(RoutesBuilder.route(doc))

    @staticmethod
    def route(mapping):
        """Return a Gloo route"""
        r = dict()
        r["matcher"] = RoutesBuilder.matcher(mapping)
        plugins = RoutesBuilder.route_plugins(mapping)
        if plugins is not None:
            r["routePlugins"] = plugins
        r["routeAction"] = RoutesBuilder.route_action(mapping)
        return r  
    
    @staticmethod
    def matcher(mapping):
        """Return a gloo matcher"""
        m = dict()
        if "prefix_regex" in mapping and mapping[ "prefix_regex"]:
            m["regex"] = mapping["prefix"]
        elif "prefix" in mapping and mapping["prefix"]:
            m["prefix"] = mapping["prefix"]
        m["methods"] = RoutesBuilder.methods(mapping)
        return m
    
    @staticmethod
    def route_plugins(mapping):
        """Return a gloo routePlugins"""
        r = dict()
        if "rewrite" not in mapping:
            r["prefixRewrite"] = RoutesBuilder.prefix_rewrite("/")
        elif mapping["rewrite"] != "":
            r["prefixRewrite"] = RoutesBuilder.prefix_rewrite(mapping["rewrite"])
        else:  
            return None
        return r
    
    @staticmethod
    def methods(mapping):
        m = list()
        if "method_regex" in mapping and mapping[ "method_regex"]:
            m = mapping["method"].split("|")
        else:
            m.append(mapping["method"])
        return m
    
    @staticmethod
    def prefix_rewrite(path):
        """Return a gloo prefix rewrite rule"""
        return { "prefixRewrite" : path }
    
    @staticmethod
    def service_and_port(mapping):
        """Return a service and port"""
        s = mapping["service"]
        name = mapping["name"]
        if ":" in s:
            (svc_with_namespace,port) = s.split(":")
        else:
            port = 80
            svc_with_namespace = s
        svc = svc_with_namespace.replace(".default","")
        return svc, int(port)
    
    @staticmethod
    def refs(mappings):
        d = dict()
        for mapping in mappings:
            service, port = RoutesBuilder.service_and_port(mapping)
            name = service + "-" + str(port) 
            if name not in d:
                d[name] = { "service" : service, "port" : port }
        return d.values()     
    
    @staticmethod
    def ref(service, port):
        """Return a gloo Upstream Ref."""
        return metadata_spec(ENVIRONMENT + "-" + service + "-" + str(port), ENVIRONMENT)
    
    @staticmethod
    def single(mapping):
        """Return a gloo single."""
        s = dict()
        service, port = RoutesBuilder.service_and_port(mapping)
        s["upstream"] = RoutesBuilder.ref(service, port)
        return s
    
    @staticmethod
    def route_action(mapping):
        """Return a gloo routeAction"""
        r = dict()
        r["single"] = RoutesBuilder.single(mapping)
        return r
    
    @staticmethod
    def ordered(routes):
        """Return a sorted list of http routes from least general to most general."""
        # sort by length of prefix/regex from longest to shortest
        return sorted(routes, key=RoutesBuilder.sort_key, reverse=True)
    
    @staticmethod
    def sort_key(route):
        """ Return a key to use in sorting paths"""
        matcher = route["matcher"]
        if "regex" in matcher:
            return len(matcher["regex"])
        elif "prefix" in matcher:
            return len(matcher["prefix"])
        elif "exact" in matcher:
            return len(matcher["exact"])
        else:
            return 0

class ManifestBuilder:
    """Build all Gloo manifests needed to route to the Tidepool backend for the given protocol.

       As fas as the API Gateway is concerned, the internal traffic
       is routed via HTTP.  The external traffic may be HTTP or
       HTTPS.

       If both the internal traffic and the external traffic come
       in via HTTP, then the the Gateway Proxy will listen for both
       on the same port.  The external virtual service may be
       listening for any host ("*").  Therefore, we cannot have two
       separate virtual services, since both may match the internal
       host name which would generate an ambiguity. So, we use a single
       virtual service that listens for traffic on the external
       host name and the internal host name. If *should* not be an error
       for two hostnames for the same virtual service to match the incoming
       host header.

       If the external traffic is HTTPS, then we create two virtual services. 
    """

    def __init__(self, mappings):
        self.mappings = mappings
        self.routes = RoutesBuilder(mappings).get()

    def external(self, protocol):
        d = dict()
        for base,ordered in self.routes.items():
            name = VIRTUAL_HOST_KEY + "-" + EXTERNAL_VS_NAME + "-" + protocol
            if protocol == "https":
                self.add(d, VirtualServiceBuilder(ordered, name, CORS_POLICY, "https", [HOST]).get())
            else:
                self.add(d, VirtualServiceBuilder(ordered, name, None, "http", [HOST]).get())
        return d

    def internal(self):
        d = dict()
        for base,ordered in self.routes.items():
            self.add(d, VirtualServiceBuilder(ordered, INTERNAL_VS_NAME, None, "http", [ INTERNAL_VS_NAME + "." + ENVIRONMENT]).get())
        for ref in RoutesBuilder.refs(self.mappings):
            self.add(d, UpstreamBuilder(ref).get())
        return d
    
    def add(self, manifest_dict, manifest):
        if manifest is not None:
            service_name = manifest["metadata"]["name"].replace(ENVIRONMENT + "-","").replace(INTERNAL_VS_NAME, "internal")
            service_kind = manifest["kind"].lower()
            name = "gloo-" + service_name + "-" + service_kind
            manifest_dict[name] = manifest

    def write(self, manifest_dict):
        print(yaml.dump(manifest_dict, explicit_start = True, default_flow_style=False))

def main(kind, protocol):
    builder=ManifestBuilder(yaml.safe_load(sys.stdin))
    if kind  == "internal":
        builder.write(builder.internal())
    else:
        builder.write(builder.external(protocol))

if __name__ == "__main__":
   main(sys.argv[1], sys.argv[2])
